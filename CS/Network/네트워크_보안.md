# 네트워크 보안
## 데이터 암호화 방식

### 대칭키

- 하나의 대칭키를 이용해서 데이터의 암호화 복호화한다.
- 대칭키는 암호화와 복호화 속도가 매우 빠르다.
- 키를 상대방에게 전달하는 과정에서 탈취될 위험이 있다.

### 공개키

- 공개키는 모든 사람에게 공개되 있다. 개인키는 데이터를 복호화하는 주체만 가지고 있다.
- 데이터를 암호화할 때는 공개키(public key)를 사용한다. 데이터를 복호화할 때는 개인키(private key)를 사용한다.
- 대칭키에 비해 데이터 복호화 속도가 느리다.

💡개인키로 데이터를 암호화하고 공개키로 복호화할 수도 있다.

💡SSL 통신에서는 대칭키를 교환하기 위해서 공개키 방식을 사용한다.

💡p와 np 알고리즘

- p 문제
    - 다항 시간동안 해결할 수 있는 알고리즘이 존재한 문제
- np 문제
    - 다행 시간동안 해결할 알고리즘을 아직 발견 못한 문제
    - 해결할 수 있는 알고리즘이 없는지, 아니면 아직 발견 못한 건지 모르는 상황이다.

## 인증

데이터를 암호화해도 중간에 공격자가 데이터를 기록한 후 그대로 전송한다면 보안이 뚤리게된다.

이를 위해 아래와 같은 과정을 거친다.

1. 서버는 클라이언트가 로그인할 때 랜덤한 숫자를 전송한다.
2. 클라이언트는 랜덤한 숫자를 자신의 개인키로 암호화해서 전달한다.
3. 서버는 클라이언트에게 공개키를 요청한다.
4. 클라이언트는 서버에게 공개키를 전달한다.
5. 서버는 랜덤한 숫자를 클라이언트의 공개키로 복호화한다.

하지만 위 방법의 4번 과정에서 서버는 전달받은 공개키가 정말 통신을 하던 클라이언트의 공개키인지 확인할 수 없다는 맹점이 있다.

 위의 맹점을 해결하기 위해 인증기관(CA)이 필요하다.

클라이언트는 인증기관의 공개키로 암호화된 자신의 공개키를 서버에 전달하고, 서버는 인증 기관의 개인키로 복호화해서 클라이언트의 공개키를 얻는다.

💡위 과정은 브라우저가 서버와 SSL 통신을 하는 과정과 유사하다. 다만 위 과정에서 클라이언트와 서버의 관계가 반대로 됐다.

💡브라우저에는 인증기관의 개인키가 내장돼 있다. 따라서 브라우저는 인증기관의 공개키를 복호화해서 서버의 공개키를 얻을 수 있다.

## 전자 서명

전달할 메시지의 무결성과 인증을 동시에 하기위해 사용되는 방식이다.

이를 위해서 메시지를 개인키로 암호화하고 상대방에게 전달하면 된다. 하지만 메시지의 길이가 길 경우 암호화하는 시간이 너무 오래걸리는 문제가 있다.

따라서 보통의 전자 서명은 아래와 같은 과정을 거친다.

1. Sender는 메시지를 Hash 함수를 통해 작은 데이터로 축소한 후 개인키로 암호화한다.
2. Sender는 메시지와 암호화된 데이터를 Receiver에게 보낸다.
3. Receiver는 암호화된 데이터를 Sender의 공개키로 복호화한다.
4. Receiver는 전달받은 메시지를 Hash 함수를 통해 변환하고 공개키로 복호화한 데이터와 비교해서 메시지의 무결성을 확인한다.

💡해시 함수는 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다.

💡해시 함수의 결과값으로 인풋 값을 추축할 수 없다.

## 보안 메일(Securing Email)

보안 메일 역시 데이터의 무결성과 인증과정을 거치기 위해서 전자 서명과 유사한 방식을 사용한다.

Sender는 총 3개의 키를 사용한다.

- Sender의 개인키
- Receiver의 공개키
- 새로 생성된 대칭키

암호화된 이메일은 동작 과정은 다음과 같다.

1. Sender는 메시지를 해시 함수를 이용해서 작은 데이터로 축소한 후 자신의 개인키로 데이터를 암호화한다.
2. Sender는 1에서 암호화한 데이터와 메시지를 대칭키로 암호화한다.
3. Sender는 2에서 암호화한 데이터와 대칭키를 Receiver의 공개키로 암호화한 후 Reciver에게 전달한다.
4. Receiver는 자신의 개인키와 대칭키 그리고 Sender의 공개키로 데이터를 복호화하고 데이터의 무결성을 검증한다.

💡과거에는 인증기관이 없었기 때문에 명함을 교환할 때 자신의 공개키를 함께 전달했다.

## TCP와 SSL

HTTP 통신의 경우 데이터를 암호화하지 않으면 네트워크 중간에 누구나 데이터를 확인할 수 있다.

이를 해결하기 위해서 TCP 소켓에 데이터를 전송하기 이전에 데이터를 암호화해야한다.

위 암호화 과정을 자동화한 것이 SSL이다. 최근에는 SSL 대신 TLS라는 용어로 많이 사용한다.

- SSL은 TCP 통신을 기반으로 동작한다. SSL 통해 통신을 하기 위해서는 먼저 TCP의 연결(3 way handshake) 과정을 거쳐야한다.
- SSL 통신 과정은 다음과 같다.
    1. 클라이언트는 서버에게 하나의 요청을 보낸다.(Client Hello)
    2. CA의 개인키로 암호화된 자신의 공개키(SSL 인증서)를 클라이언트에 전달한다.
    3. 클라이언트는 브라우저에 내장된 CA의 공개키 목록으로 서버의 공개키를 획득하고, 마스터 키를 서버의 공개키로 암호화하여 서버에 전달한다.
    4. 서버는 클라이언트로 부터 전달받은 데이터를 자신의 개인키로 복호화해서 마스터 키를 획득한다.
- 마스터 키에는 4가지 종류의 키가 존재한다.
    - Kc - Client에서 Server로 데이터를 보낼 때 암호화하는 키
    - Mc - Client에서 Server로 전달할 데이터의 MAC을 암호화하는 키
    - Ks - Server에서 Client로 데이터를 보낼 때 암호화하는 키
    - Ms - Server에서 Client로 전달할 데이터의 MAC을 암호화하는 키

💡MAC(Message Authentication Code) 메시지의 무결성을 검증하기 위해 사용하는 방식이다. 전달할 메시지와 키를 함께 해시 함수로 이용해서 MAC 코드로 변환한다. Receiver는 메시지와 키를 이용해서 해시 함수로 코드를 생성하고 전달받은 MAC 코드와 비교해서 메시지의 무결성을 검증한다.

💡SSL sequence number도 이용해서 MAC 코드를 생성하면 메시지 순서를 임의로 조정하는 reordering 공격을 방지할 수 있다.

💡공격자가 임의로 FIN 메시지를 보내는 것을 방지하기 위해 type 필드도 사용된다. type 필드가 1이면 해당 메시지 FIN이고, 0이면 FIN이 아닌것을 의미한다. MAC을 생성할 때 type 필드도 함께 사용할 수 있다.

💡불법 사이트의 접속을 차단하기 위해서 간단히 사용하는 방식이 HTTP Request의 host ip 주소 기준으로 접속 차단을 결정하는 방식이다. 하지만 이러한 방식은 Request의 host ip를 확인할 수 없는(암호화 됐기 때문에) HTTPS 통신에서는 사용할수 없다.