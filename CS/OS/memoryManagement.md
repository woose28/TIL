## 📌 메모리 관리(Memory Management)

### 💡 사전 지식
1. 사용자 프로그램 처리 과정
- 소스파일 - (컴파일러) -> 오브젝트 파일 - (링커) -> 실행 파일 - (로더) -> 메모리에 저잭의 프로그램
- 소스 파일
    - 소스 파일의 메모리 주소는 숫자 형태가 아니라 변수 이름과 같은 형태이다.
    - 이러한 형태의 주소를 `심볼릭 주소(Symbolic address)`라고 한다.
- `컴파일러(Compiler)`는 `심볼릭 주소`를 `재배치 가능 주소(Relocatable address)`로 변환한다.
    - `재배치 가능 주소`는 첫 번째 주소로부터 열 번째 옆에 있는 주소와 같은 표현
- `링커(Linker)`는 링커는 컴파일러에 의해 생성된 여러 오브젝트 파일을 하나의 실행 파일로 결합하는 역할을 한다.
- `로더(Loader)`는 사용자 프로그램을 `물리 메모리(Physical address)`에 적재하는 역할을 한다.

<br>

### ✔️ 주소 공간
- 논리 주소(Logical address 또는 Virtual address)
    - 각 프로세스마다 독립적으로 가지는 주소 공간
    - 각 프로세스마다 0번지부터 시작
    - CPU가 보는 주소는 logical address이다.

- 물리 주소(Pyhsical address)
    - 메모리에 실제 올라가는 위치

<br>

### ✔️ 주소 바인딩(Address binding)
- 물리적인 메모리 주소를 결정하는 것
- 물리적인 메모리 주소를 결정하는 시점에 따라 세 가지로 나뉜다.
    - 컴파일 타임 바인딩(Compile time binding)
        - 프로세스가 메모리에 올라갈 주소 공간을 알 수 있을 때 사용하는 방식
        - 컴파일 할 때 물리 주소 공간이 결정된다.
        - 컴파일러는 `절대 코드(Absolute code)`를 생성한다.
            - 논리 주소와 물리 주소가 일치한다.
            - 프로세스의 시작 위치를 바꾸려면 다시 컴파일 과정이 필요하다.(recompile)
        - 현재 잘 사용하지 않는 방법

    - 로드 타임 바인딩(Load time binding)
        - `로더`에 의해 물리적인 메모리 공간이 결정된다.(프로그램이 시작될 때 물리적인 메모리 공간이 결정)
        - 컴파일러는 `재배치 가능 코드(Relocatable code)`를 생성한다.
        - 메모리 로딩 시간(적재 시간)이 긴 단점이 있다.
            - 프로세스가 메모리에 적재될 떄, 모든 논리 주소를 물리 주소로 한번에 바꾼다.
        - multi programming이 가능하다.

    - 실행 시간 바인딩(Execution time binding 또는 Run time binding)
        - 프로그램이 실핼될 때 물리적인 메모리 공간이 결정된다.
        - 단, 프로그램 실행 도중 물리적인 메모리 공간이 변경될 수 있다.
        - `MMU(Memory Management Unit)`과 같은 하드웨어의 지원이 필요하다.
        - 지금 사용하는 컴퓨터 시스템은 `실행 시간 바인딩`을 사용한다.
        - multi programming이 가능하다.

<br>

### ✔️ 메모리 관리 장치(Memory Management Unit)
- `논리 주소 공간`을 `물리 주소 공간`으로 연결해 주는 하드웨어 장치
- 메모리 관리 장치에 `논리 주소 공간` 값을 전달하면 그에 해당하는 `물리 주소 공간` 값을 반환해 준다.
- 메모리 관리 장치의 레지스터
    - 재배치 레지스터(relocate register) 또는 기준 레지스터(base register)
        - 프로그램의 시작 위치를 저장한다.
        - 프로세스가 CPU에서 실행돼서 얻은 논리적 주소 값에 재배치 레지스터에 저장된 값을 더해서 물리적 주소 값을 계산한다.

    - 상항 레지스터(limit register)
        - 프로그램 영역의 크기를 저장한다.
        - 하나의 사용자 프로세스가 다른 사용자의 프로세스 공간에 침범하는 것을 방지할 때 사용한다.
        - 상한 레지스터 값에 벗어나는 논리 주소 값을 요청하면 `트랩(trap)`이 발생한다.
            - `트랩(trap)`이 발생되면 커널 모드로 전환된다.

<br>

### ✔️ 동적 적재(Dynamic Loading)
- 프로세스 전체를 메모리에 한 번에 적재시키는 것이 아니라, 해당 루틴이 불릴 때 메모리에 적재시키는 방법
- 자주 사용되지 않은 코드는 사용될 때 메모리에 적재할 수 있기 때문에 메모리 효율이 증가한다.
- 운영체제가 직접 해주는 것이 아니라, 사용자 프로그래머가 해당 기능을 구현한다.
    - 단, OS는 동적 적재를 구현하는 라이브러리를 제공해 준다.
    - 이 부분에서 `페이징 기법`과 차이가 있다.
        - 프로그래머가 명시적 해당 기능을 구현하는 것이 dynamic loading이고, OS가 자체적으로 해당 기능을 수행해 주는 것이 `페이징 기법`이라고 구분할 수 있다.
        - 비슷하게 `overlay`라는 것도 존재하는데, 이 기법은 OS 라이브러리 지원 없이 프로그래머가 메모리에 적재되는 부분과 다시 내려오는 부분을 수작업으로 구현하는 방법이다.
            - 주로 메모리 크기가 작고, 초창기 시스템에서 프로그래머가 프로세스를 실행시키기 위해 이 기법을 사용했다.

<br>

### ✔️ 스와핑(Swapping)
- 프로세스를 메모리의 영역에서 일시적으로 내보내는 행위
- 메로리 영역에서 내보내진 프로세스는 `Backing Store(= Swap area)`에 저장된다.
    - `Backing Store`는 하드웨어 공간이다.
- swap in과 swap out
    - swap in
        - 메모리 영역에서 `Backing Store`으로 이동하는 경우
    - swap out
        - `Backging Store`에서 메모리 영역으로 이동하는 경우
- `중기 스케줄러(스와퍼)`와 관련됐다.
    - 주로 CPU 스케줄러에서 우선순위가 낮은 프로세스가 스와퍼에 의해 `swap out`된다.
- 주소 바인딩 방법에 따른 `swap in`의 차이점
    - `컴파일 타임 바인딩`과 `로드 타임 바인딩`은 프로세스가 `swap in`이 될 때 원래 메모리 위치로 다시 적재돼야 한다.
    - `실행 시간 바인딩`은 `swap in`이 될 때 아무 빈 공간에 적재돼도 된다.


<br>

### ✔️ 정적 연결(Static Linking)과 동적 연결(Dynamic Linking)
- 정적 연결
    - 라이브러리가 실행 파일에 코드에 포함되는 방법
    - 실행 파일의 크기가 커진다.
    - 동일한 라이브러리를 사용하는 프로세스가 여러 개가 있다면, 동일한 라이브러리 코드가 해당 프로세스들의 실행 파일에 중복되므로 메모리 낭비가 발생한다.

- 동적 연결
    - 라이브러리가 실행 시 연결(Link)된다.
    - 실행 파일에 들어가는 것은 라이브러리 코드를 실행할 위치 값만 들어간다.
        - 라이브러리가 이미 메모리에 이미 적재됐다면 그대로 사용할 수 있다.
        - 그렇지 않다면, 메모리에 적재한 후 사용한다.
    - 동적 연결을 사용한 라이브러리는 여러 프로세스에서 공유해서 사용할 수 있다.
        - 동적 연결을 할 수 있는 라이브러리를 `공유 라이브러리(Shared Library)`라고 한다.
    - 동적 연결은 운영체제의 도움이 필요하다.
        - 사용자 프로세스는 자신의 메모리 영역에만 접근이 가능하기 때문에!

<br>

### 📚 참고 자료
- [KOCW 운영체제 Ch.Memory Mnagement- 반효경 교수님](http://www.kocw.net/home/search/kemView.do?kemId=1046323)
- [Address binding 로드 타임 바인딩... - 양햄찌가 만드는 세상](https://jhnyang.tistory.com/246)
- [Difference between compile time ,load time and execution time? - Stack Overflow](https://stackoverflow.com/questions/35729139/difference-between-compile-time-load-time-and-execution-time)

<br>

<img alt="크리에이티브 커먼즈 라이선스" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" />